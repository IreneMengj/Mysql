<b>1. Basic knowledge of Java</b>
1. Object class related methods<br>
<b>getClass</b>  Gets the Class object of the current runtime object.<br>
<b>hashCode</b> Returns the hash code of an object.<br>
<b>clone</b> copies the current object and must implement the <b>Cloneable</b> interface. <b>Shallow copy</b> copy the value of the basic type and copy the reference type. <b>Deep copy</b> copies the value of the basic type, and copies not only the reference of the object but also the properties and methods of the object. The difference is that deep copy creates a new object.<br>
<b>equals</b> compares two objects to each other by memory address. The String class overrides this method by using values to compare equality.<br>
<b>toString</b> returns the class name @ hash code in hexadecimal.<br>
<b>notify</b> Wakes up any thread of the current object monitor.<br>
<b>notifyAll</b> wakes up all threads on the current object monitor.<br>
<b>wait</b> 1. Pause the execution of the thread. 2. Three methods with different parameters (wait milliseconds; How many extra milliseconds to wait; 3. In contrast to Thread.sleep(long time), sleep puts the current Thread to sleep for a period of time without releasing the lock on the object. wait releases the lock.<br>
<b>finalize</b> The method to execute when a finalize object is collected by the garbage collector.<br>


<b>2、Basic data type</b>
Integral type：byte(8)、short(16)、int(32)、long(64)<br>
Floating point type：float(32)、double(64)<br>
boolean：boolean(8)<br>
char：char(16)<br>

<b>3. Serialization</b>
Java object serialization implements the Serializable interface.<br>

Deserialization does not call the constructor. Unsequenced objects are objects that are generated by the JVM itself, not by constructors.<br>
The reference type member variable of the serialized object must also be serializable, otherwise, an error will be reported.<br>
If you want a variable not to be serialized, use the transient modifier.<br>
Serialize the singleton class, requiring overriding the readResolve() method.<br>

<b>4. String, StringBuffer, StringBuilder</b><br>
A String consists of a char[] array, is final, is immutable, can be understood as a constant, and is thread-safe; Each time a change is made to a String, a new String is generated, and the pointer is pointed to the new reference object.<br>
StringBuffer thread safe; The StringBuiler thread is not secure.<br>
String for small amounts of character data; StringBuilder for single-threaded manipulation of large amounts of data; A StringBuffer is used for multithreaded manipulation of large amounts of data.<br>

<b>5. Overloading and rewriting</b><br>
Overloading occurs in the same class. The method name is the same, the type, number, and order of arguments are different, and the return value and modifiers of the method can be different.<br>
Overrides occur in parent and child classes where the method name and parameter are the same, the return value range is less than or equal to the parent class, the exception range is less than or equal to the parent class, and the access modifier range is greater than or equal to the parent class. If the superclass method access modifier is private or final, the subclass cannot override the method.<br>

<b>6. final</b><br>
Modifies primitive type variables so that they cannot be modified once they are out of initialization.<br>
Modifies a reference type variable and cannot point to another reference.<br>
Modifies a class or method that cannot be inherited or overridden.<br>

<b>7. Reflection</b><br>
Get the complete information of the class dynamically at run time<br>
Increase the flexibility of the program<br>
The JDK dynamic proxy uses reflection<br>

<b>8. JDK dynamic proxy</b><br>
Use procedure<br>
Create interfaces and implementation classes<br>
Implement Proxy handler: implement InvokationHandler and invoke (Proxy proxy, Method method, Object[] args) method<br>
Obtain the Proxy classes through proxy.newproxyInstance (ClassLoaderloader, Class[] interfaces, InvocationHandler h)<br>
Invoke a method through a proxy class.<br>

<b>9. Java IO</b><br>
Normal IO, stream oriented, synchronous blocking thread.<br>
NIO, buffer oriented, synchronous non-blocking.<br>

<b>2.Java collection framework</b><br>
<b>1. List (linear structure)</b><br>
ArrayList Object[] array implementation, the default size is 10, support random access, continuous memory space, end insertion time complexity o(1), insertion time complexity i position o(n - i). Array. copyOf (underlying System.ArrayCopy) is copied to a new array. The pointer points to the new array.
A Vector is thread-safe, like an ArrayList. By default, it grows to twice the size of an ArrayList.<br>
LinkedList is based on Linkedlist implementation. 1.7 is a bidirectional linked list and 1.6 is a bidirectional circular linked list.<br>
<b>2. Map (K, V pairs)</b><br>
<b>HashMap</b><br>
The underlying data structure, JDK 1.8 is array + linked list + red-black tree, JDK 1.7 no red-black tree. When the length of the list is greater than 8, it is converted into a red-black tree to optimize query efficiency.<br>
The initial capacity is 16. Use tableSizeFor to ensure that the capacity is raised to the power of 2. Addressing mode, high XOR, (n-1)&h modulo, optimize speed.<br>
Expansion mechanism: When the number of elements is greater than the capacity x load factor 0.75, the capacity is doubled, an array is created, and then transferred to the new array.<br>
Based on Map implementation.<br>
The thread is not safe.<br>
HashMap (1.7) Multithreaded loop linked list problem<br>
In a multithreaded environment, the HashMap in 1.7 forms a circular linked list during capacity expansion.<br>
How to form A circular list: Suppose you have a HashMap of capacity 2, stored as A -> B list at array index 1. A thread has put operations on the map. Expansion conditions are triggered and the map needs to be expanded. Procedure At this time, another thread also put operation, also need to expand the expansion operation, and completed the expansion operation, because copy to the new array is the head insert, so the 1 position becomes B -> A. At this time, the first thread continues to perform the expansion operation, first copying A, then copying B, and then judging whether B.next is empty, because the second thread does the expansion operation, causing B.next = A, so before placing A in front of B, A.next = B, resulting in the circular linked list.<br>
<b>HashTable</b><br>
Thread-safe, methods are almost entirely Synchronized.<br>
The initial capacity is 11, and the expansion capacity is 2n + 1.<br>
Inherits the Dictionary class.<br>
<b>ConcurrentHashMap</b><br>
Thread-safe HashMap.<br>
1.7 Locking in the form of segmental locking; 1.8 Synchronized and CAS are used to achieve synchronization. If the Node in the array is empty, the value is set by CAS; if not, it is added to the first node in the linked list. Getting whether the first element is empty guarantees visibility using the getObjectVolatile provided by the Unsafe class.<br>
For reads, the array is volatile, the element of the array is Node, the K of Node is final, the V is volatile, and the next node is volatile to ensure the visibility of multiple threads.<br>
LinkedHashMap LinkedHashMap inherits from HashMap, so its underlying structure is still based on a zip chain hash structure consisting of arrays and linked lists or red-black trees. In addition, LinkedHashMap adds a bidirectional linked list to the above structure, allowing the above structure to maintain the insertion order of key-value pairs.<br>
TreeMap ordered Map, red-black tree structure, can be customized comparator to sort.<br>
Collections.synchronizedmap how to implement the Map thread safe? Based on Synchronized, it essentially locks the currently passed Map object.<br>
<b>3. Set (unique value)</b><br>
HashSet is based on the HashMap implementation, which uses K of HashMap as the element store and V as new Object(). If the Hash values of two elements are the same in the add() method, the equals method is used to compare whether they are equal.<br>
A LinkedHashSet inherits from a HashSet and is internally implemented through a LinkedHashMap.<br>
The TreeSet red-black tree is ordered and unique.<br>

<b>3.Java multithreading</b><br>
1. synchronized<br>
Modifies the underlying implementation of the code block by marking it as a synchronous code block through monitorenter & monitorexit.<br>
Modifies the underlying implementation of the method, indicating that the method is synchronized by ACC_SYNCHRONIZED.<br>
When you modify a class object, you actually lock onto an instance of the class.<br>
Singleton pattern<br>
public class Singleton {

    private static volatile Singleton instance = null;

    private Singleton(){}

    public static Singleton getInstance(){
    if (null == instance) {
        synchronized (Singleton.class) {
            if (null == instance) {
            instance = new Singleton();
            }
        }
      }
        return instance;
        }
}<br>
<b>Bias lock, spin lock, lightweight lock, heavyweight lock</b><br>
With synchronized, the first thread acquires a biased lock, and then other threads compete for the lock and upgrade to a lightweight lock. The other threads attempt to acquire the lock in a cyclic manner, called spin locks. If the number of spins reaches a certain threshold, it is upgraded to a heavyweight lock.<br>
Note that when the second thread acquires a lock, it determines if the first thread is still alive, and if it is not, it is not upgraded to a lightweight lock.<br>

2. Lock<br>
ReentrantLock<br>
Based on AbstractQueuedSynchronizer (AQS) implementation, there are mainly the state (resources) + FIFO (thread waiting queue).<br>
Fair lock and unfair lock: The difference is that when a lock is acquired, the fair lock determines whether there are waiting threads in the current queue, and queues them if there are.<br>
Use the lock() and unLock() methods to unlock.<br>
ReentrantReadWriteLock<br>
Also based on the AQS implementation, the internal use of inner class to implement the read lock (shared lock) and write lock (exclusive lock).<br>
The unfair lock throughput is high in the lock acquisition phase. When a thread wants to acquire a lock, the unfair lock can directly attempt to acquire the lock, rather than judging whether there is a thread waiting in the current queue. In some cases, frequent context switching can be avoided. In this way, the active thread may acquire the lock, but the lock in the queue must be woken up before it can continue to attempt to acquire the lock, and the execution order of the thread generally does not affect the running of the program.<br>

<b>3、volatile</b><br>
Java memory model<br>
![image](https://user-images.githubusercontent.com/88880169/219709447-4f1c2588-1a2e-475b-97cc-3d65fb90e397.png)

Ensure variable visibility in multithreaded environments. When volatile modifies a variable, it is synchronized to main memory immediately after it is modified, and flushed from main memory each time the variable is used.<br>
Disallow JVM instruction reordering.<br>
Why is the singleton double check lock variable volatile? JVM instructions are not allowed to reorder. new Object() is divided into three steps: apply for memory space, assign memory space references to variables, and initialize variables. If reordering is not prohibited, it is possible to get an uninitialized variable.<br>

4. The five states of threads<br>
1). New<br>
A new thread has been created and has not yet started running.<br>

2). Runnable<br>
A thread enters the Runnable state when it is ready to run.<br>

The Runnable state can be a thread that is actually running or a thread that is ready to run.<br>

In a multithreaded environment, each thread is allocated a fixed amount of CPU time. Each thread runs for a while and then stops to allow other threads to run, so that each thread can run fairly. These waiting cpus and running threads are in the Runnable state.<br>

3). Blocked<br>
For example, if a thread is waiting for an I/O resource, or if the protected code it wants to access has been locked by another thread, it will be in the Blocked state, and the thread will be in the Runnable state once the required resources are in place.<br>

4) Waiting (for a long time)<br>
If a thread is Waiting for another thread to wake it up, it is in the waiting state. The following methods put the thread into a wait state:<br>

Object.wait()<br>
Thread.join()<br>
LockSupport.park()<br>
5) The Timed Waiting table<br>
The system automatically wakes up after a certain period of time without waiting for other threads to display wake up.<br>

The following methods put the thread into a finite wait state:<br>

Thread.sleep(sleeptime)<br>
Object.wait(timeout)<br>
Thread.join(timeout)<br>
LockSupport.parkNanos(timeout)<br>
LockSupport.parkUntil(timeout)<br>
6). Terminated<br>
When a thread completes normally, or fails unexpectedly, it is finished.<br>

5. wait() and sleep()<br>
The thread enters the waiting state after the call.<br>
wait() releases the lock, sleep() does not.<br>
A call to wait() requires a call to notify() or notifyAll() to wake up the thread.<br>
The wait() method is declared in Object and the sleep() method is declared in Thread.
6. yield()<br>
The thread enters the runnable state after the invocation.<br>
The CPU time slice is freed up, and it is possible that another thread later gains execution rights, or that thread continues to execute.<br>
7. join()<br>
The Join() method of thread A is called in thread B, and the execution of thread B will not continue until thread A finishes executing.<br>
Sequential execution of threads is guaranteed.<br>
The join() method must be called after the thread has started to be meaningful.<br>
This is implemented using the wait() method.<br>
